% $Header:
% /cvsroot/latex-beamer/latex-beamer/solutions/conference-talks/conference-ornate-20min.en.tex,v 1.6 2004/10/07 20:53:08 tantau Exp $

\documentclass{beamer}
%\documentclass[handout]{beamer}
%\documentclass{beamer}
\usepackage{xspace}
\usepackage{listings}
\usepackage{relsize}
\usepackage{proof}
\RequirePackage{amsmath,amssymb}
\usepackage{pgfarrows}

\usepackage{hyperref}

% remove next three lines for animated slides
%% \usepackage{pgfpages}
%% \pgfpagesuselayout{4 on 1}[letterpaper,border shrink=5mm,landscape]
%% \mode<handout>{\setbeamercolor{background canvas}{bg=black!5}}

\def\kwd#1{\ensuremath{\text{\ttfamily #1}}\xspace}

\def\ktype{\kwd{Type}}
\def\sep{\; | \;}
\def\app{\,}
\def\ra{\rightarrow}

\newcommand{\eq}{{\it eq}}
\newcommand{\refl}{{\it refl}}
\newcommand{\sarr}{{\it arr}}
\newcommand{\sapp}{{\it app}}
\newcommand{\slam}{{\it lam}}
\newcommand{\sty}{{\it ty}}
\newcommand{\stm}{{\it tm}}
\newcommand{\of}{{\it of}}
\newcommand{\ofapp}{{\it of\_app}}
\newcommand{\oflam}{{\it of\_lam}}

\newcommand{\lambdasans}[2]{\lambda #1.\,#2}
\newcommand{\lambdax}[3]{\lambda #1 : #2.\, #3}
\newcommand{\typedpi}[3]{\Pi #1 : #2.\, #3}

\newcommand{\lfder}[2]{#1 \vdash #2}
\newcommand{\seq}[5]{#1;#2;#3;#4\longrightarrow #5}
\newcommand{\seqsans}[2]{#1\longrightarrow #2}

%\newcommand{\subs}[2]{#1[#2]}

%\input{header}
% This file is a solution template for:

% - Talk at a conference/colloquium.
% - Talk length is about 20min.
% - Style is ornate.


\mode<presentation>
{
  \usetheme{Warsaw}
  %\usetheme{Boadilla}
  %\usetheme{Dresden}
  % or ...

  \setbeamercovered{transparent}
  % or whatever (possibly just delete it)
}


\usepackage[english]{babel}
% or whatever

\usepackage[latin1]{inputenc}
% or whatever

\usepackage{times}
\usepackage[T1]{fontenc}
% Or whatever. Note that the encoding and the font should match. If T1
% does not look nice, try deleting the line with the fontenc.


\title[Reasoning about Specifications in LF]{Reasoning about
  Specifications in LF}


\author{Gopalan Nadathur}
% - Give the names in the same order as the appear in the paper.
% - Use the \inst{?} command only if the authors have different
%   affiliation.

\institute{Department of Computer
  Science and Engineering \\
University of Minnesota}

% - Use the \inst command only if there are several affiliations.
% - Keep it simple, no one is interested in your street address.

\date[LFMTP 2022] % (optional, should be abbreviation of conference name)
     {Joint work with Mary Southern and Chase Johnson\\[5pt]
       Presented at a Special Session in (Delayed) Celebration of\\
       Frank Pfenning's 60th Birthday}

% - Either use conference name or its abbreviation.
% - Not really informative to the audience, more for people (including
%   yourself) who are reading the slides online


% If you wish to uncover everything in a step-wise fashion, uncomment
% the following command:

%\beamerdefaultoverlayspecification{<+->}

\begin{document}

\begin{frame}
  \titlepage
\end{frame}

\begin{frame}[t]
\frametitle{The Logical Framework (LF)}

A typed $\lambda$-calculus in which types can depend on
terms
\begin{align*}
  \text{Kinds} & \qquad           K ::= \ktype \sep \typedpi{x}{A}{K}\\
  \text{Types} &\qquad   A, B ::= a \sep \typedpi{x}{A}{B} \sep A\app M \\
  \text{Terms}& \qquad         M, N ::= c \sep x \sep \lambdasans{x}{M} \sep M\app N
\end{align*}


\medskip
Typing judgements are relativized to \emph{signatures}  and \emph{contexts}
\begin{align*}
  \text{Signatures} & \qquad     \Sigma ::= \cdot \sep \Sigma, a: K
  \sep \Sigma, c: A \\
  \text{Contexts}   & \qquad     \Gamma ::= \cdot \sep \Gamma, x : A
\end{align*}


\medskip
The focus today will be on judgements of the form $\Gamma
\vdash_\Sigma M : A$

%% \bigskip
%% Note that types can depend on the context in such judgements

\bigskip
We will also assume that all expressions are in \emph{canonical form}
\end{frame}

\begin{frame}[t]
\frametitle{Specifications in LF}

Object systems are described by identifying a suitable signature

\bigskip
For example, the STLC may be described by the following $\Sigma$

\vspace{-0.5cm}
\begin{center}
\begin{tabular}{l}

\begin{tabular}{ll}
     $\sty : \ktype$ & $\sarr : \sty \ra \sty \ra \sty$ \\[7pt]
     $\stm : \ktype$ & $\sapp : \stm \ra \stm \ra \stm$\\
                     & $\slam : \sty \ra (\stm \ra \stm) \ra \stm$\\[7pt]
\end{tabular}

\\
\begin{tabular}{l}
$\of : \stm \ra \sty \ra \ktype$\\[5pt]

$\ofapp :\typedpi{M_1}{\stm}
                 {\typedpi{M_2}{\stm}
                          {\typedpi{{\it Ty}_1}{\sty}
                                   {\typedpi{{\it Ty}_2}{\sty}}}}$\\
\quad$\of\app M_1\app (\sarr\app {\it Ty}_1\app {\it Ty}_2) \ra
            \of\app M_2\app {\it Ty}_1 \ra
            \of\app (\sapp\app M_1\app M_2)\app {\it Ty}_2$\\[5pt]
$\oflam  : \typedpi{{\it Ty}_1}{\sty}
                   {\typedpi{{\it Ty}_2}{\sty}
                            {\typedpi{M}{\stm \ra \stm}{}}}$\\
\ $\typedpi{y}{\typedpi{x}{\stm}{\of\app x\app {\it Ty}_1 \ra 
                    \of\app (M\app x)\app {\it Ty_2}}}{
                      \of \app (\slam \app {\it Ty}_1 \app  M) \app
                               (\sarr\app {\it Ty}_1\app {\it Ty}_2)}$
\end{tabular}

\end{tabular}
\end{center}

\medskip
Eventually, the LF judgement $\vdash_\Sigma D : \of \app M \app A$
asserts that $D$ is an STLC derivation of the fact that $M$ has type $A$
\end{frame}

\begin{frame}[t]
\frametitle{The Twelf Approach to Proving Meta-Theorems}

Properties of object systems are encoded by defining new type
constructors with mode declarations

\begin{tabbing}
\quad\=\qquad\=\kill
\>${\it eq} : \sty \ra \sty \ra \ktype$\\
\>${\it refl} : \typedpi{T}{\sty}{{\it eq}\app T \app T}$\\[5pt]

\>$\mbox{\it ty\_uniq} : \typedpi{M}{\stm}{\typedpi{{\it
      Ty}_1}{\sty}{\typedpi{{\it Ty}_2}{\sty}{}}}$\\
\>\> $\of \app M \app {\it Ty}_1 \ra \of \app M \app {\it Ty}_2 \ra
     {\it eq}\app {\it Ty}_1 \app {\it Ty}_2 \ra \ktype$\\[5pt]

\> \mbox{\it mode\ +M +Ty1 +Ty2 +D1 +D2 -D3}
\end{tabbing}

A proof of the property amounts to showing how to
  construct outputs for all relevant input values

\bigskip
The method provides constructive proofs for
  $\forall\exists$ statements about LF judgements with a common context

\bigskip
Our work is motivated by a desire for a more flexible treatment
  of logical symbols and contexts
\end{frame}

\begin{frame}[t]
  \frametitle{The Components of Our Approach}

Reasoning capabilities are realized in two steps

\medskip
\begin{itemize}
\item  Developing a logic for stating properties about derivability in  
  LF relative to a signature

\medskip
\begin{itemize}
\item Typing judgements a la LF as atomic formulas

\medskip
\item The usual collection of logical connectives

\medskip
\item Quantification over terms and contexts
\end{itemize}

\medskip
\item Identifying proof rules that facilitate sound reasoning relative
  to the logic

\medskip
Key part: the treatment of atomic formulas
\end{itemize}

\medskip
The proof assistant Adelfa constitutes a practical realization
\end{frame}

\begin{frame}[t]
\frametitle{The Treatment of Term Variables}

The two extremes for typing term variables

\medskip
\begin{itemize}
\item assume that they are untyped

\medskip
\item accord them a dependent type
\end{itemize}

\medskip
The first makes wellformedness a part of typing assertions

\medskip
The second is unworkable because typing depends on contexts

\bigskip
\begin{uncoverenv}<2->
The chosen alternative is to use \emph{arity typing}: simple types
constructed from $o$

\bigskip
Arity types will be represented by $\tau$, possibly with subscripts
\end{uncoverenv}
\end{frame}


\begin{frame}[t]
\frametitle{The Treatment of Contexts}

Two considerations underlie the representation of contexts

\medskip
\begin{itemize}
\item Variables bound in a context must be interpreted differently
  from variables bound by quantifiers

\medskip
Using \emph{nominal constants} for the former provides the necessary
distinction 

\medskip\smallskip
\item Contexts that arise in reasoning can have two parts

\medskip
\begin{itemize}
\item An explicit part arising from the analysis of typing

\medskip
\item An initial, unspecified part represented by a variable
\end{itemize}
\end{itemize}

\begin{uncoverenv}<2->
\bigskip
This leads to the following syntax for context expressions
\begin{align*}
G \quad &::= \quad \Gamma\ |\ \cdot\ |\ G,n:A
\end{align*} 
where $\Gamma$ and $n$ represent context variables and nominal
constants, respectively
\end{uncoverenv}
\end{frame}

\begin{frame}[t]
\frametitle{Context Schemas and Instances}

Instantiations for context variables must follow a regular structure
indicated by typing them with a \emph{context schema}
\begin{align*}
Block \ &::=\ (x_1:\tau_1,\ldots,x_n:\tau_n)[y_1:A_1,\ldots,y_m:A_m]\\
Blocks \ &::=\ Block\ |\ Blocks,Block\\
Context\ Schema \ &::=\ \mbox{\sl id} = Blocks
\end{align*}

\medskip
A declaration sequence $n_1:C_1,\ldots,n_m:C_m$ is an \emph{instance}
of a block $(x_1:\tau_1,\ldots,x_n:\tau_n)[y_1:A_1,\ldots,y_m:A_m]$ if, for $1 \leq i \leq m$,
\[C_i = A_i[t_1/x_1,\ldots,t_n/x_n,n_1/y_1,\ldots,n_{i-1}/y_{i-1}]\]

\medskip
A context expression satisfies a context schema if it is a listing of
declaration sequences instantiating some of its blocks
\end{frame}

\begin{frame}
\frametitle{Formulas and their Interpretation}

The syntax for formulas 
\begin{align*}
  F\ ::= \ & \top \sep \bot \sep \{\lfder{G}{M : A}\} \sep F_1\wedge
  F_2 \sep F_1\vee F_2 \sep \\
           & F_1\supset F_2\ |\ \forall x:\tau.F\ |\ \exists
  x:\tau.F\ |\ \Pi\Gamma:\mbox{\sl id}.F
\end{align*}
Term variables and nominal constants may appear in $M$ 
and $A$

\bigskip
\begin{uncoverenv}<2->
Validity for closed formulas is based on LF derivability relative to a
parameterizing signature $\Sigma$, e.g.

\smallskip
\begin{itemize}
\item A closed formula $\{\lfder{G}{M:A}\}$ is valid if
  $\vdash_\Sigma G\,\mbox{\sl ctx}$,
  $G \vdash_\Sigma A\,\mbox{\sl type}$, and $G \vdash_\Sigma M : A$ are
  derivable in LF

\medskip
\item $\forall x:\tau.F$ is valid if $F[t/x]$ holds
  for every closed expression $t$ of arity type $\tau$

%% \smallskip
%% \item $\exists x:\tau.F$ is valid if $F[t/X]$ holds
%%   for some closed expression $t$ of arity type $\tau$
  
\medskip
\item $\Pi\Gamma:\mbox{\sl id}. F$ holds if $F[G/\Gamma]$ holds for
  every closed context expression $G$ that satisfies the context schema $id$
\end{itemize}

\medskip
Note that quantifiers are given a \emph{substitution semantics}
\end{uncoverenv}
\end{frame}

\begin{frame}[t]
\frametitle{An Example}

Let $\Sigma$ be the signature for the STLC identified earlier

\medskip
Let {\sl ctx} be the context schema defined as follows:
\[ \mbox{\sl ctx} = (T:ty)[x:tm,y:\of~x~T] \]

Then the uniqueness of type assignment for the STLC is represented by
the following formula
\begin{tabbing}
\quad\=\qquad\=\qquad\=\kill
\>$\Pi\Gamma:\mbox{\sl ctx}.\forall E:o.\forall {\it Ty}_1:o .\forall {\it Ty}_2:o.\forall D_1:o.\forall D_2:o.$\\
\>\> $\{\lfder{\Gamma}{D_1:\of~E~{\it Ty}_1}\}\supset \{\lfder{\Gamma}{D_2:\of~E~{\it Ty}_2}\}\supset $\\
\>\>\>$\exists D_3:o.\{\lfder{\cdot}{D_3:eq\app {\it Ty}_1\app {\it Ty}_2}\}$
\end{tabbing}

\end{frame}

\begin{frame}[t]
\frametitle{Sequents and Partially Elaborated Contexts}

Sequents have the form $\seq{\mathbb N}{\Psi}{\Xi}{\Delta}{F}$ where

\smallskip
\begin{itemize}
\item $\mathbb N$ is a collection of (typed) nominal constants

\smallskip
\item $\Psi$ is a listing of term variables with types

\smallskip
\item $\Xi$ comprises declarations of the form
  $\Gamma\uparrow {\mathbb N}_\Gamma : id\lbrack {b_1,\ldots,b_n}\rbrack$

\smallskip
\item $\Delta$ is a set of (assumption) formulas, and

\smallskip
\item $F$ is a (conclusion) formula
\end{itemize}

\bigskip
Here, $\mathbb N$, $\Psi$ and $\Xi$ determine the nominal
constants and term and context variables that can appear in the sequent

\bigskip
The \emph{typing}
$\Gamma\uparrow {\mathbb N}_\Gamma : id\lbrack {b_1,\ldots,b_n}\rbrack$
is to be read as follows:

\smallskip
\begin{itemize}
\item $\Gamma$ has been partially instantiated to
$\Gamma_1,b_1,\ldots,\Gamma_n,b_n,\Gamma_{n+1}$ where each
  $\Gamma_i$ is a context variable

\medskip
\item Instantiations of $\Gamma$ must satisfy {\sl id} and must not use the nominals in
  ${\mathbb N}_\Gamma$
\end{itemize}

\end{frame}

\begin{frame}[t]
\frametitle{Validity for Sequents}

This notion builds again around that for closed sequents:

\smallskip
\begin{itemize}
\item A sequent of the form $\seq{\mathbb
  N}{\emptyset}{\emptyset}{\Delta}{F}$ is  valid if $F$ is valid or some
  formula in $\Delta$ is not valid

\medskip\smallskip
\item The sequent $\seq{\mathbb N}{\Psi}{\Xi}{\Delta}{F}$ is 
valid if all of its closed instances obtained by

\smallskip
\begin{itemize}
\item fully elaborating each context variable in $\Xi$ in a manner
  consistent with the interpretation of its type, and

\medskip 
\item instantiating the term variables in $\Psi$ with closed terms free
  of nominal constants
\end{itemize}
is valid

\medskip\smallskip
\item Validity of a closed formula $F$ whose nominal constants
  are contained in $\mathbb N$ coincides with the validity of
  $\seq{\mathbb N}{\emptyset}{\emptyset}{\emptyset}{F}$
\end{itemize}
\end{frame}

\begin{frame}[t]
\frametitle{The Structure of the Proof System}

The proof rules are of three kinds

\smallskip
\begin{itemize}
\item a core set embodying structural aspects of sequents and the
  meanings of the logical symbols

\medskip
\item those encoding metatheorems about LF derivability

\medskip
\item those that build in an
  understanding of LF typing rules
\end{itemize}

\medskip
We illustrate the last kind through a glimpse at the case analysis and
induction rule
\end{frame}

\begin{frame}[t]
\frametitle{Analyzing Inhabitation for an Atomic Type}

The sequent under consideration has the form

\vspace{-0.2cm}
\[\seq{\mathbb N}{\mathcal{C}}{\Psi}{\Delta\uplus\big\{\{G \vdash {M : a\app
    N_1\app \ldots\app N_m}\}\big\}}{F}\]

\begin{uncoverenv}<2->
\medskip
Conceptually, for every constant in $\Sigma$ and nominal constant in
$G$ that can yield a term $(h\app t_1\app \ldots\app t_n)$

\begin{itemize}
\item that is identical to $M$, and

\medskip
\item with a type identical to $(a\app N_1\app\ldots\app N_m)$
\end{itemize}

we must generate a premise sequent by replacing $\{G \vdash {M : a\app
  N_1\ldots\app N_m}\}$  with typing judgements for $t_1,\ldots,t_n$
\end{uncoverenv}

\bigskip
\uncover<3->{One complicating factor: $M$ and $(a\app N_1 \app \ldots \app N_m)$ may
contain term variables}

\bigskip
\uncover<4->{Another complicating factor: $G$ may contain a context variable}
\end{frame}

\begin{frame}[t]
\frametitle{Elaborating Blocks for a Context Variable}

Suppose that the atomic formula being analyzed is

\vspace{-0.2cm}
\[\{\Gamma, n_1:A_1, \ldots, n_m:A_m \vdash M : A\}\]

%\vspace{-0.2cm}
and $\Xi$ has the declaration $\Gamma \uparrow
       {\mathbb N_\Gamma} : \mbox{\sl id}[b_1,\ldots,b_n]$

\bigskip\smallskip
Then the ``head'' $h$ for $M$ can come from one of the following parts
of the context expression

\smallskip
\begin{itemize}
\item the sequence of nominal constants $n_1, \ldots, n_m$,

\medskip
\item one of the blocks $b_1,\ldots, b_n$, or

\medskip
\item an as yet unelaborated part of $\Gamma$
\end{itemize}

\medskip
The last possibility is handled by \emph{block elaboration}
\end{frame}

\begin{frame}[t]
\frametitle{An Illustration of Block Elaboration}

Assume the context declaration $ctx = (T:\sty).[x:\stm,y:\of\app x \app T]$

\bigskip
Also suppose that $\Xi$ contains the declaration $\Gamma\uparrow\emptyset : tyctx[.]$


\bigskip
The analysis of $\{\lfder{\Gamma}{D : \of\app E\app Ty}\}$ based
on block elaboration will then result in the following

\smallskip
\begin{itemize}
\item The declaration for $\Gamma$ in $\Xi$
  will be replaced by $\Gamma\uparrow\emptyset : ctx[n_1 : \stm, n_2 : \of\app n_1\app T]$

\medskip
\item The nominal constant $n_2$ will be considered as a head for $D$
\end{itemize}
\end{frame}

\begin{frame}
\frametitle{Accommodating Inductive Arguments}

Induction based on the heights of LF derivations is supported

\bigskip
For example, in demonstrating the validity of 
\begin{tabbing}
\quad\=\qquad\=\qquad\=\kill
\>$\Pi\Gamma:\mbox{\sl ctx}.\forall E:o.\forall {\it Ty}_1:o .\forall {\it Ty}_2:o.\forall D_1:o.\forall D_2:o.$\\
\>\> $\{\lfder{\Gamma}{D_1:\of~E~{\it Ty}_1}\}\supset \{\lfder{\Gamma}{D_2:\of~E~{\it Ty}_2}\}\supset $\\
\>\>\>$\exists D_3:o.\{\lfder{\cdot}{D_3:eq\app {\it Ty}_1\app {\it Ty}_2}\}$
\end{tabbing}

this formula can be assumed for instances of
$\{\lfder{\Gamma}{D_1:\of~E~{\it Ty}_1}\}$ that have shorter
derivations

\bigskip
The main components in realizing induction:

\smallskip
\begin{itemize}
\item a rule for introducing an induction hypothesis

\medskip
\item a mechanism for noting the reduction in derivation height in the case
  analysis rule
\end{itemize}

\bigskip
The specific mechanism is inspired by the annotation scheme used in
the Abella proof assistant
\end{frame}

\begin{frame}[t]
\frametitle{Concluding Remarks}

\begin{itemize}
\item A complete development with soundness proofs appears in
  \href{https://arxiv.org/abs/2107.00111}{\color{blue}{A Logic for Reasoning About LF Specifications}}

\medskip
\item Related in spirit to the two-level logic approach exploited in
  Abella-LF but also significant differences in detail

\medskip
\item Extensions to include fixed-point definitions and $\nabla$
  quantification seem worth considering

\medskip  
\item A careful comparison of the capabilities of Adelfa with systems
  like Twelf and Beluga is of interest
\end{itemize}
\end{frame}

%% \begin{frame}
%% \frametitle{Analyzing Inhabitation for an Atomic Type}

%% The sequent under consideration has the form
%% \[\seq{\mathbb N}{\mathcal{C}}{\Psi}{\Delta\uplus\big\{\{G \vdash {M : a\app
%%     N_1\ldots\app N_m}\}\big\}}{F}\]

%% \medskip
%% Let $h$ be a constant in $\Sigma$ or a nominal constant in $G$ with type
%% \[\typedpi{x_1}{A_1}{\ldots\typedpi{x_n}{A_n}{(a\app B_1\app\ldots\app
%%     B_m)}}\]

%% \bigskip
%% Further, for $1 \leq i \leq n$, let $t_i$ be terms constructed by raising a new
%% eigenvariable $X_i$ over $\mathbb N$ 

%% \bigskip
%% Then for each such $h$ and for each unifier $\sigma$ for
%% \begin{tabbing}
%% \quad\=$\{\langle M, (h\app t_1\app \ldots \app t_n)\rangle,\ $\=\kill
%% \> $\{\langle M, (h\app t_1\app \ldots \app t_n)\rangle, \langle N_1, B_1[t_1/x_1,\ldots,t_n/x_n]\rangle, \ldots,$\\
%% \>\>$\langle N_m,B_m[t_1/x_1,\ldots,t_n/x_n] \rangle\}$
%% \end{tabbing}

%% we must consider as a premise the sequent obtained by

%% \begin{itemize}
%% \item replacing $\{G \vdash {M : a\app N_1\ldots\app N_m}\}$  in the
%%   assumptions with
%%   $\{\lfder{G}{X_1:A_1}\},\ldots,\{\lfder{G}{X_n:A_n[t_1/x_1,\ldots,t_{n-1}/x_{n-1}]}\}$

%% \medskip
%% \item and applying the substitution $\sigma$ to the result
%% \end{itemize}
%% \end{frame}

\end{document}
