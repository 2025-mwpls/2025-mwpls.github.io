% $Header:
% /cvsroot/latex-beamer/latex-beamer/solutions/conference-talks/conference-ornate-20min.en.tex,v 1.6 2004/10/07 20:53:08 tantau Exp $

\documentclass{beamer}
%\documentclass[handout]{beamer}
%\documentclass{beamer}
\usepackage{xspace}
\usepackage{listings}
\usepackage{relsize}
\usepackage{proof}
\RequirePackage{amsmath,amssymb}
\usepackage{pgfarrows}

\usepackage{hyperref}

% remove next three lines for animated slides
%% \usepackage{pgfpages}
%% \pgfpagesuselayout{4 on 1}[letterpaper,border shrink=5mm,landscape]
%% \mode<handout>{\setbeamercolor{background canvas}{bg=black!5}}

\def\kwd#1{\ensuremath{\text{\ttfamily #1}}\xspace}

\def\ktype{\kwd{Type}}
\def\sep{\; | \;}
\def\app{\,}
\def\ra{\rightarrow}

\newcommand{\eq}{{\it eq}}
\newcommand{\refl}{{\it refl}}
\newcommand{\sarr}{{\it arr}}
\newcommand{\sapp}{{\it app}}
\newcommand{\slam}{{\it lam}}
\newcommand{\sty}{{\it ty}}
\newcommand{\stm}{{\it tm}}
\newcommand{\of}{{\it of}}
\newcommand{\ofapp}{{\it of\_app}}
\newcommand{\oflam}{{\it of\_lam}}

\newcommand{\lambdasans}[2]{\lambda #1.\,#2}
\newcommand{\lambdax}[3]{\lambda #1 : #2.\, #3}

\setbeamertemplate{footline}
{\insertpagenumber}

%\newcommand{\subs}[2]{#1[#2]}

%\input{header}
% This file is a solution template for:

% - Talk at a conference/colloquium.
% - Talk length is about 20min.
% - Style is ornate.


\mode<presentation>
{
  \usetheme{Warsaw}
  %\usetheme{Boadilla}
  %\usetheme{Dresden}
  % or ...

  \setbeamercovered{transparent}
  % or whatever (possibly just delete it)
}


\usepackage[english]{babel}
% or whatever

\usepackage[latin1]{inputenc}
% or whatever

\usepackage{times}
\usepackage[T1]{fontenc}
% Or whatever. Note that the encoding and the font should match. If T1
% does not look nice, try deleting the line with the fontenc.


\title[Binding Contexts as Partitionable Multisets]
      {Binding Contexts as\\
       Partitionable Multisets in Abella}


\author{Terrance Gray and Gopalan Nadathur}
% - Give the names in the same order as the appear in the paper.
% - Use the \inst{?} command only if the authors have different
%   affiliation.

\institute{Department of Computer
  Science and Engineering \\
University of Minnesota}

% - Use the \inst command only if there are several affiliations.
% - Keep it simple, no one is interested in your street address.

\date[LFMTP 2024] % (optional, should be abbreviation of conference name)

% - Either use conference name or its abbreviation.
% - Not really informative to the audience, more for people (including
%   yourself) who are reading the slides online


% If you wish to uncover everything in a step-wise fashion, uncomment
% the following command:

%\beamerdefaultoverlayspecification{<+->}

\begin{document}

\begin{frame}
  \titlepage
\end{frame}

\begin{frame}[t]
\frametitle{Overview of the Talk}

\medskip
  \begin{itemize}
  \item Binding contexts and how they arise

  \bigskip
  \item The treatment of binding contexts in Abella

  \bigskip
  \item The motivation for a ``partitionable multiset'' treatment

  \bigskip
  \item Our proposal for providing such a treatment

  \bigskip
  \item Hints at automating the treatment

  \bigskip
  \item Ongoing and related work
  \end{itemize}
\end{frame}

\begin{frame}[t]
\frametitle{What are Binding Contexts?}

\medskip

\begin{itemize}
\item Associations between variables and data such as a type, a
  translation, a substitution, etc

\bigskip
\item Arise in the course of computing with, analyzing, and reasoning
  about objects with binding structure

  \medskip
  Such object include programs, formulas, types, and proofs

\bigskip
\item Binding contexts typically have associated properties, e.g.,

  \medskip
  \begin{itemize}
  \item associations are of a particular shape and for variables only

  \medskip
  \item associations are unique
  \end{itemize}

\bigskip
\item These properties are important for analysis and reasoning
\end{itemize}
\end{frame}

\begin{frame}[t]
\frametitle{Type Assignment in the STLC}

Terms and types

\begin{center}
  \begin{tabular}{ccl}
    $\alpha$ & \mbox{::=} & $\iota\ |\ \alpha \rightarrow \alpha$\\
    \mbox{\sl e}  & \mbox{::=} & $\mbox{x}\ |\ (\mbox{\sl e}\ \mbox{\sl
      e})\ |\ \lambdax{x}{\alpha}{\mbox{\sl e}}$
  \end{tabular}
\end{center}

\bigskip
Typing judgements: $\Gamma \vdash \mbox{\sl e} : \mbox{\sl ty}$, where
$\Gamma$ is a binding context 

\bigskip
The typing rules

\medskip
\begin{center}
\begin{tabular}{cc}

  \infer{\Gamma \vdash x : \alpha}
        { x : \alpha \in \Gamma}

  \quad
  &
  \quad
  
\infer[x\ \mbox{new to}\ \Gamma]
          {\Gamma \vdash \lambdax{x}{\alpha'}{e} : \alpha' \ra \alpha}
          {\Gamma, x : \alpha' \vdash e : \alpha}
\\[10pt]
        
\multicolumn{2}{c}
  {   \infer{\Gamma \vdash (e_1\app e_2) : \alpha}
        {\Gamma \vdash e_1 : \alpha' \ra \alpha \qquad \Gamma \vdash e_2 :
          \alpha'}
  }
\end{tabular}
\end{center}

\bigskip
Observe the invariants implicitly satisfied by $\Gamma$
\end{frame}

\begin{frame}[t]
  \frametitle{Reasoning About Type Assignment}

  Properties of the binding context need to be made explicit in
  reasoning 

  \bigskip
  For example, consider showing uniqueness of type assigment

  \vspace{-0.2cm}
  \[\forall \Gamma,e,\alpha,\alpha'.\ 
      \Gamma \vdash e : \alpha \supset
      \Gamma \vdash e : \alpha' \supset \alpha = \alpha'\]

  \bigskip
  The proof depends explicitly on properties of $\Gamma$

  \medskip
  \begin{itemize}
    \item Only variables are assigned types by $\Gamma$

    \medskip
    \item Every such assignment is to a distinct variable
  \end{itemize}
\end{frame}

\begin{frame}[t]
  \frametitle{Abella and Reasoning about Formal Systems}

%  Based on a predicate logic built on an intuitionistic base

%  \bigskip
  Three key features make it suitable for this purpose

  \medskip
  \begin{itemize}
    \item Support for a higher-order representation of abstract syntax

      \medskip
      E.g., lambda terms would be represented as follows

      \smallskip
      \begin{tabbing}
        \qquad\=$\lambdax{x}{\alpha}{e}\quad$\=$\longrightarrow\quad$\=\kill
        \>$(e_1\app e_2)$ \> $\longrightarrow$ \>
                      $(\mbox{\sl app}\ \widehat{e_1}\ \widehat{e_2})$\\
        \>$\lambdax{x}{\alpha}{e}$ \> $\longrightarrow$ \>
                      $(\mbox{\sl abs}\ \widehat{\alpha}\
                                        (\lambda x. \widehat{e}))$
      \end{tabbing}

      Here $\widehat{e}$ (similarly $\widehat{\alpha}$)  denotes the
      representation of $e$ ($\alpha$)

    \bigskip
    \item The ``nabla'' quantifier: $\nabla x.F$ or $\mbox{\sl nabla x, F}$

      \medskip
       Equivalent to $F[n/x]$ for a \emph{nominal constant} $n$ fresh
       to $F$

       %% \medskip
       %% Yields a means for moving binding to the logical level

    \bigskip
    \item Inductive definitions for atomic predicates via
      clauses in which we can control nominal constant occurrences
  \end{itemize}
\end{frame}

\begin{frame}[t,fragile]
  \frametitle{Specifying Type Assignment in Abella}

  Type assignment represented by ternary predicate $\mbox{\sl typeof}$

  \bigskip
  Predicate is defined inductively by clauses mirroring the type
  assignment rules

  \begin{verbatim}
  typeof G X Ty := member (varty X Ty) G;
  typeof G (app M N) Ty :=
    exists Ty', typeof G M (arrow Ty' Ty) /\
                typeof G N Ty';
  typeof G (abs Ty E) (arrow Ty Ty') :=
    nabla x, typeof (varty x Ty :: G) (E x) Ty'.
  \end{verbatim}

  %% Here $(\mbox{\sl arrow}\ \widehat{\alpha_1} \widehat{\alpha_2})$
  %% represents the type $(\alpha_1 \rightarrow \alpha_2)$

  Note that contexts are represented by lists of the form

  \vspace{-0.2cm}
  \[ (\mbox{\sl varty}\ n_1\ \widehat{\alpha_1})\ ::\ \cdots\ ::\ (\mbox{\sl
    varty}\ n_k\ \widehat{\alpha_k})\ ::\ \mbox{\sl nil}\]

  where $n_1,\ldots, n_k$ are \emph{distinct} nominal constants
\end{frame}

\begin{frame}[t,fragile]
  \frametitle{Characterizing Typing Contexts in Abella}

  ``Good context'' can be identified by recursion on list
  structure:

  \smallskip
  \begin{itemize}
  \item The empty list is a good context

  \smallskip
  \item A context of the form $(\mbox{\sl varty}\ n\ \alpha) :: G$ is good
    provided

    \smallskip
    \begin{itemize}
    \item $n$ is a nominal constant not appearing in $G$

    \smallskip
    \item $G$ is a good context
    \end{itemize}
  \end{itemize}

  \bigskip
\begin{uncoverenv}<2->
  Abella definitions can encode such properties

\vspace{-0.2cm}
\begin{verbatim}
           ctx nil ;
  nabla x, ctx (varty x Ty :: G) := ctx G.
\end{verbatim}

\medskip
To generate instances of the clauses

\smallskip
\begin{itemize}
  \item Instantiate nabla in clause head with a nominal
    constant

  \medskip
  \item Instantiate other variables with terms not containing the constant
\end{itemize}
\end{uncoverenv}
\end{frame}

\begin{frame}[t,fragile]
  \frametitle{Provable Properties of Contexts Based on Definitions}

  Uniqueness and membership lemmas follow from such definitions

  \bigskip
  For example, the following can be proved by induction on the definition,
  where \verb+name+ identifies nominal constants:

\begin{verbatim}
Theorem ty_ctx_uniq : forall G X Ty1 Ty2,
  ctx G -> member (varty X Ty1) G -> 
           member (varty X Ty2) G -> Ty1 = Ty2.

Theorem ty_ctx_mem : forall G X,
  ctx G -> member X L -> 
           exists n Ty, name n /\ X = varty n Ty.
\end{verbatim}

\medskip
Thus, using \verb+ctx+ to qualify contexts, theorems such as
uniqueness of typing can be proved
\end{frame}

\begin{frame}[t]
  \frametitle{Resource-Oriented View of Binding Contexts}

Arises when linearity is superimposed on the analysis of objects with
binding constructs

\bigskip
For example, consider type assignment for the STLC where every bound
variable must be used exactly once

\medskip
\begin{center}
\begin{tabular}{cc}

  \infer{x : \alpha \vdash x : \alpha}
        {}

  \quad
  &
  \quad
  
  \infer[x\ \mbox{new to}\ \Gamma]
          {\Gamma \vdash \lambdax{x}{\alpha'}{e} : \alpha' \ra \alpha}
          {\Gamma, x : \alpha' \vdash e : \alpha}
\\[15pt]
        
\multicolumn{2}{c}
  { \infer{\Gamma \vdash (e_1\app e_2) : \alpha}
        {\Gamma = \Gamma_1 \uplus \Gamma_2 \qquad
         \Gamma_1 \vdash e_1 : \alpha' \ra \alpha \qquad
         \Gamma_2 \vdash e_2 : \alpha'}
  }
\end{tabular}
\end{center}

\bigskip
In general, it must be possible to view binding contexts as multisets
that can also be partitioned
\end{frame}

\begin{frame}[t,fragile]
  \frametitle{Building in the Partitionable Multiset View}


  Two main components provide this capability

  \medskip
  \begin{itemize}
     \item Augmenting the ``list'' structure with a new infix multiset
       union constructor \verb^++^ 

    \medskip
     \item Treating the resulting structure as permutation invariant,
       realized via a defined (infix) predicate\ \ $\sim$
  \end{itemize}

  \bigskip
  Thus, multisets have three constructors: {\sl nil}, ::, and
  \verb^++^

  \bigskip
  The :: operator adds an element (somewhere) to a multiset
  
  \bigskip
  Partitioning $G$ into $G_1$ and $G_2$ is represented by $G \sim (G_1\ \mbox{\tt ++}\ G_2)$
\end{frame}

\begin{frame}[t,fragile]
  \frametitle{Defining Good Context in Multiset Form}

  Cannot be done via a direct inductive definition: $G_1$ and $G_2$
  being good contexts does not imply $G_1\ \mbox{++}\ G_2$ is also

  \bigskip
  \begin{uncoverenv}<2->
  The key idea: lift it to arbitrary contexts via permutations from
  contexts built one item at a time

  \bigskip
  E.g., the following works for typing contexts in the extended syntax:

\begin{verbatim}
           ctx' nil ;
  nabla x, ctx' (varty x Ty :: G) := ctx' G.

           ctx G := 
               exists G', G ~ G' /\ ctx' G'.
\end{verbatim}

Note: The property of being a good context is also permutation
invariant
\end{uncoverenv}
\end{frame}

\begin{frame}[t,fragile]
  \frametitle{Proving Membership and Uniqueness Properties}

  The main observation is that membership is invariant under permutation to
  multisets:

\begin{verbatim}
  Theorem mem_perm : forall X G G', 
    member X G -> G ~ G' -> member X G'.
\end{verbatim}

Thus, these properties can also be lifted from contexts in simple form
\end{frame}

\begin{frame}[t,fragile]
  \frametitle{Multiset Union and the Context Property}

  Inductive arguments require the property of being a
  good context to distribute over partitioning

  \bigskip\medskip
  For example, consider the application rule when showing type
  uniqueness for the linear STLC 

  \medskip
  \begin{center}
  \begin{tabular}{c}
     \infer{\Gamma \vdash (e_1\app e_2) : \alpha}
           {\Gamma = \Gamma_1 \uplus \Gamma_2 \qquad
             \Gamma_1 \vdash e_1 : \alpha' \ra \alpha \qquad
             \Gamma_2 \vdash e_2 : \alpha'}
  \end{tabular}
  \end{center}

  \medskip
  Induction hypothesis requires $\Gamma_1$
  and $\Gamma_2$ to be good contexts
  
  \bigskip\medskip
  Concretely, we must show the following:
\begin{verbatim}
   Theorem ctx_distr : forall G G1 G2,
       ctx G -> G ~ (G1 ++ G2) 
             -> ctx G1 /\ ctx G2.
\end{verbatim}
\end{frame}
  
\begin{frame}[t,fragile]
\frametitle{Showing Distributivity over Multiset Union}

A lifting-style argument can be used here too:

\medskip
\begin{itemize}
\item Define an ``ordered'' partition predicate over simple multisets 

  %% \begin{center}
  %%   \verb+part L L1 L2+ means \verb+L1+ and \verb+L2+
  %%   partition \verb+L+
  %% \end{center}

\bigskip
\item Show the base context predicate distributes over this style of
  partitioning

  \medskip
  Ordering in the definition makes it easy to prove

%% \begin{verbatim}
%%   Theorem part_distr : forall L L1 L2,
%%     ctx' L -> part L L1 L2 
%%            -> ctx' L1 /\ ctx' L2
%% \end{verbatim}

\bigskip
\item Show general partitioning implies special partitioning up to
  permutations

%% \begin{verbatim}
%%    Theorem perm_to_part : forall L G1 G2,
%%      islist L -> L ~ G1 ++ G2 
%%               -> exists L1 L2, 
%%                  L1 ~ G1 /\ L2 ~ G2 /\ partition L L1 L2
%% \end{verbatim}

\bigskip
\item Utilize the invariance of the context predicate under
  permutations 
\end{itemize}
\end{frame}

\begin{frame}
  \frametitle{Generalization to Context Relations}

  Context predicates are a special case of a more general phenomenon

  \smallskip
  \begin{itemize}
    \item Multiple analyses may pertain to the same or related expressions
      involving binding

      \smallskip
      E.g., translation between source and object language, type
      assignment for both languages

      \bigskip
    \item Each analysis may be parameterized by a binding context of a
      particular shape

      \bigskip
      \item Relationships between the different binding contexts are
        needed for proving cumulative properties

        \smallskip
        E.g., type preservation over a translation
  \end{itemize}

  \medskip
  Ideas exposed with context predicates extend smoothly to
  context relations
\end{frame}

\begin{frame}[t]
  \frametitle{Towards an Automation of the Ideas}

  Many aspects of the overall scheme can be realized with minimal
  human intervention:

  \medskip
  \begin{itemize}
    \item Dual context definitions can be generated from a description
      of context elements

      \medskip
    \item Lemmas about permutations and invariance under them are
      independent of context particulars

      \medskip
      \item Distributivity lemmas over multiset union 
        can be automatically generated

      \medskip
      \item Uniqueness and membership lemmas can be generated once the
        base form of the lemma is known
  \end{itemize}

  \medskip
  A new version of Abella will incorporate these ideas
\end{frame}

\begin{frame}[t,fragile]
  \frametitle{Abella and a Linear Specification Logic}

  \begin{itemize}
    \item Abella supports a two-level logic approach through a deep
      embedding of a specification logic in a reasoning logic

      \bigskip
    \item A treatment of partitionable multisets becomes important when
      a linear specification logic is used

      \bigskip
      \item This work is relevant when the specification logic is used
        to encode computations over formal objects
  \end{itemize}
\end{frame}

\begin{frame}[t]
  \frametitle{Related Work}

  \begin{itemize}
    \item Chaudhuri et al. describe similar ideas for reasoning about
      linear logic in Abella but using just the list structure

      \medskip
    \item Laurent describes a deep embedding of linear logic in Coq
      using an explicit exchange rule 

      \medskip
    \item Georges et al. use something like an ordered multiset union
      in a treatment of linear LF judgements as types

      \medskip
    \item Crary describes a treatment of linearity separately from
      that of contexts
  \end{itemize}
\end{frame}
      
\end{document}
